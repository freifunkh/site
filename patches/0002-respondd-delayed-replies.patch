From 33cb352b9bc55ab72c8dab4ceed4c12cb032ef31 Mon Sep 17 00:00:00 2001
From: lemoer <git@irrelefant.net>
Date: Mon, 30 Jan 2017 00:33:17 +0100
Subject: [PATCH] respondd: backport support for delayed replies

---
 ...d-support-for-delayed-replies-to-multicas.patch | 442 +++++++++++++++++++++
 1 file changed, 442 insertions(+)
 create mode 100644 patches/packages/gluon/0001-respondd-add-support-for-delayed-replies-to-multicas.patch

diff --git a/patches/packages/gluon/0001-respondd-add-support-for-delayed-replies-to-multicas.patch b/patches/packages/gluon/0001-respondd-add-support-for-delayed-replies-to-multicas.patch
new file mode 100644
index 00000000..06110b30
--- /dev/null
+++ b/patches/packages/gluon/0001-respondd-add-support-for-delayed-replies-to-multicas.patch
@@ -0,0 +1,442 @@
+From 48eb14ec052d1bf19dfc0deabe86557b95340d89 Mon Sep 17 00:00:00 2001
+From: lemoer <git@irrelefant.net>
+Date: Tue, 6 Dec 2016 19:46:40 +0100
+Subject: [PATCH] respondd: add support for delayed replies to multicast
+ requests (#144)
+
+---
+ net/respondd/src/respondd.c | 302 +++++++++++++++++++++++++++++++++++++++-----
+ 1 file changed, 271 insertions(+), 31 deletions(-)
+
+diff --git a/net/respondd/src/respondd.c b/net/respondd/src/respondd.c
+index e3242da..9e91cec 100644
+--- a/net/respondd/src/respondd.c
++++ b/net/respondd/src/respondd.c
+@@ -1,6 +1,7 @@
+ /*
+    Copyright (c) 2014-2015, Nils Schneider <nils@nilsschneider.net>
+    Copyright (c) 2015-2016, Matthias Schiffer <mschiffer@universe-factory.net>
++   Copyright (c) 2016 Leonardo MÃ¶rlein <me@irrelefant.net>
+    All rights reserved.
+ 
+    Redistribution and use in source and binary forms, with or without
+@@ -41,6 +42,7 @@
+ #include <string.h>
+ #include <time.h>
+ #include <unistd.h>
++#include <errno.h>
+ 
+ #include <arpa/inet.h>
+ #include <net/if.h>
+@@ -48,6 +50,16 @@
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ 
++#define SCHEDULE_LEN 8
++#define REQUEST_MAXLEN 256
++#define MAX_MULTICAST_DELAY_DEFAULT 0
++
++struct interface_delay_info {
++	struct interface_delay_info *next;
++
++	unsigned int ifindex;
++	uint64_t max_multicast_delay;
++};
+ 
+ struct provider_list {
+ 	struct provider_list *next;
+@@ -64,6 +76,18 @@ struct request_type {
+ 	int64_t cache_timeout;
+ };
+ 
++struct request_task {
++	struct request_task *next;
++	int64_t scheduled_time;
++
++	struct sockaddr_in6 client_addr;
++	char request[REQUEST_MAXLEN];
++};
++
++struct request_schedule {
++	size_t length;
++	struct request_task *list_head;
++};
+ 
+ static int64_t now;
+ static struct hsearch_data htab;
+@@ -79,15 +103,18 @@ static void usage() {
+ 	puts("        -p <int>         port number to listen on");
+ 	puts("        -g <ip6>         multicast group, e.g. ff02::2:1001");
+ 	puts("        -i <string>      interface on which the group is joined");
++	puts("        -t <int>         maximum delay seconds before multicast responses");
++	puts("                         for the last specified multicast interface (default: 0)");
+ 	puts("        -d <string>      data provider directory (default: current directory)");
+ 	puts("        -h               this help\n");
+ }
+ 
+-static void join_mcast(const int sock, const struct in6_addr addr, const char *iface) {
++// returns true on success
++static bool join_mcast(const int sock, const struct in6_addr addr, unsigned int ifindex) {
+ 	struct ipv6_mreq mreq;
+ 
+ 	mreq.ipv6mr_multiaddr = addr;
+-	mreq.ipv6mr_interface = if_nametoindex(iface);
++	mreq.ipv6mr_interface = ifindex;
+ 
+ 	if (mreq.ipv6mr_interface == 0)
+ 		goto error;
+@@ -95,11 +122,11 @@ static void join_mcast(const int sock, const struct in6_addr addr, const char *i
+ 	if (setsockopt(sock, IPPROTO_IPV6, IPV6_JOIN_GROUP, &mreq, sizeof(mreq)) == -1)
+ 		goto error;
+ 
+-	return;
++	return true;
+ 
+  error:
+-	fprintf(stderr, "Could not join multicast group on %s: ", iface);
+ 	perror(NULL);
++	return false;
+ }
+ 
+ 
+@@ -165,6 +192,55 @@ static const struct respondd_provider_info * get_providers(const char *filename)
+ 	return ret;
+ }
+ 
++bool schedule_push_request(struct request_schedule *s, struct request_task *new_task) {
++	if (s->length >= SCHEDULE_LEN)
++		// schedule is full
++		return false;
++
++	// insert into sorted list
++	struct request_task **pos;
++	for (pos = &s->list_head; *pos; pos = &((*pos)->next)) {
++		if ((*pos)->scheduled_time > new_task->scheduled_time)
++			break;
++	}
++	// insert before *pos
++	new_task->next = *pos;
++	*pos = new_task;
++
++	s->length++;
++	return true;
++}
++
++int64_t schedule_idle_time(struct request_schedule *s) {
++	if (!s->list_head)
++		// nothing to do yet (0 = infinite time)
++		return 0;
++
++	int64_t result = s->list_head->scheduled_time - now;
++
++	if (result <= 0)
++		return -1; // zero is infinity
++	else
++		return result;
++}
++
++struct request_task * schedule_pop_request(struct request_schedule *s) {
++	if (!s->list_head)
++		// schedule is empty
++		return NULL;
++
++	if (schedule_idle_time(s) >= 0) {
++		// nothing to do yet
++		return NULL;
++	}
++
++	struct request_task *result = s->list_head;
++	s->list_head = s->list_head->next;
++	s->length--;
++
++	return result;
++}
++
+ static void load_cache_time(struct request_type *r, const char *name) {
+ 	r->cache = NULL;
+ 	r->cache_time = 0;
+@@ -308,8 +384,6 @@ static struct json_object * handle_request(char *request, bool *compress) {
+ 	if (!*request)
+ 		return NULL;
+ 
+-	update_time();
+-
+ 	if (!strncmp(request, "GET ", 4)) {
+ 		*compress = true;
+ 		return multi_request(request+4);
+@@ -320,27 +394,10 @@ static struct json_object * handle_request(char *request, bool *compress) {
+ 	}
+ }
+ 
+-
+-static void serve(int sock) {
+-	char input[256];
++void send_response(int sock, struct json_object *result, bool compress,
++                   struct sockaddr_in6 *addr) {
+ 	const char *output = NULL;
+-	ssize_t input_bytes, output_bytes;
+-	struct sockaddr_in6 addr;
+-	socklen_t addrlen = sizeof(addr);
+-	bool compress;
+-
+-	input_bytes = recvfrom(sock, input, sizeof(input)-1, 0, (struct sockaddr *)&addr, &addrlen);
+-
+-	if (input_bytes < 0) {
+-		perror("recvfrom failed");
+-		exit(EXIT_FAILURE);
+-	}
+-
+-	input[input_bytes] = 0;
+-
+-	struct json_object *result = handle_request(input, &compress);
+-	if (!result)
+-		return;
++	size_t output_bytes;
+ 
+ 	const char *str = json_object_to_json_string_ext(result, JSON_C_TO_STRING_PLAIN);
+ 
+@@ -361,13 +418,143 @@ static void serve(int sock) {
+ 	}
+ 
+ 	if (output) {
+-		if (sendto(sock, output, output_bytes, 0, (struct sockaddr *)&addr, addrlen) < 0)
++		if (sendto(sock, output, output_bytes, 0, (struct sockaddr *) addr, sizeof(*addr)) < 0)
+ 			perror("sendto failed");
+ 	}
+ 
+ 	json_object_put(result);
+ }
+ 
++void serve_request(struct request_task *task, int sock) {
++	bool compress;
++	struct json_object *result = handle_request(task->request, &compress);
++
++	if (!result)
++		return;
++
++	send_response(
++		sock,
++		result,
++		compress,
++		&task->client_addr
++	);
++}
++
++/**
++ * Wait for an incoming request and schedule it.
++ *
++ * 1a. If the schedule is empty, we wait infinite time.
++ * 1b. If we have scheduled requests, we only wait for incoming requests
++ *     until we reach the scheduling deadline.
++ * 1c. If there is no request incomming in the above time, the fuction will
++ *     return.
++ * 2a. If the incoming request was sent to a multicast destination IPv6,
++ *     check whether there was set a max multicast delay for the incomming iface
++ *     in if_delay_info_list.
++ * 2b. If so choose a random delay between 0 and max_multicast_delay milliseconds
++ *     and schedule the request.
++ * 2c. If not, send the request immediately.
++ * 2d. If the schedule is full, send the reply immediately.
++ * 3a. If the incoming request was sent to a unicast destination, the response
++ *     will be also sent immediately.
++ */
++static void accept_request(struct request_schedule *schedule, int sock,
++                           struct interface_delay_info *if_delay_info_list) {
++	char input[REQUEST_MAXLEN];
++	ssize_t input_bytes;
++	struct sockaddr_in6 addr;
++	char control[256];
++	struct in6_addr destaddr = {};
++	struct cmsghdr *cmsg;
++	unsigned int ifindex = 0;
++	int recv_errno;
++
++	int64_t timeout = schedule_idle_time(schedule);
++	if (timeout < 0)
++		return;
++
++	// set timeout to the socket
++	struct timeval t;
++	t.tv_sec = ((uint64_t) timeout) / 1000;
++	t.tv_usec = (((uint64_t) timeout) % 1000) * 1000;
++
++	if (setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &t, sizeof(t)) < 0)
++		perror("setsockopt failed\n");
++
++	struct iovec iv = {
++		.iov_base = input,
++		.iov_len = sizeof(input) - 1
++	};
++
++	struct msghdr mh = {
++		.msg_name = &addr,
++		.msg_namelen = sizeof(addr),
++		.msg_iov = &iv,
++		.msg_iovlen = 1,
++		.msg_control = control,
++		.msg_controllen = sizeof(control)
++	};
++
++	input_bytes = recvmsg(sock, &mh, 0);
++	recv_errno = errno;
++	update_time();
++
++	// Timeout
++	errno = recv_errno;
++	if (input_bytes < 0 && (errno == EAGAIN || errno == EWOULDBLOCK))
++		return;
++
++	if (input_bytes < 0) {
++		perror("recvmsg failed");
++		exit(EXIT_FAILURE);
++	}
++
++	// determine destination address
++	for (cmsg = CMSG_FIRSTHDR(&mh);	cmsg != NULL; cmsg = CMSG_NXTHDR(&mh, cmsg))
++	{
++		// skip other packet headers
++		if (cmsg->cmsg_level != IPPROTO_IPV6 || cmsg->cmsg_type != IPV6_PKTINFO)
++			continue;
++
++		struct in6_pktinfo *pi = (struct in6_pktinfo *) CMSG_DATA(cmsg);
++		destaddr = pi->ipi6_addr;
++		ifindex = pi->ipi6_ifindex;
++		break;
++	}
++
++	input[input_bytes] = 0;
++
++	// get the max delay
++	uint64_t max_multicast_delay = MAX_MULTICAST_DELAY_DEFAULT;
++	struct interface_delay_info *tmp = if_delay_info_list;
++	for (; tmp; tmp = tmp->next) {
++		if (tmp->ifindex == ifindex) {
++			max_multicast_delay = tmp->max_multicast_delay;
++			break;
++		}
++	}
++
++	struct request_task *new_task = malloc(sizeof(*new_task));
++	// the ternary operator avoids division by 0
++	new_task->scheduled_time = max_multicast_delay ? now + rand() % max_multicast_delay : 0;
++	strncpy(new_task->request, input, input_bytes + 1);
++	new_task->request[input_bytes] = 0;
++	new_task->client_addr = addr;
++
++	bool is_scheduled;
++	if(new_task->scheduled_time && IN6_IS_ADDR_MULTICAST(&destaddr))
++		// scheduling could fail because the schedule is full
++		is_scheduled = schedule_push_request(schedule, new_task);
++	else
++		// unicast packets are always sent directly
++		is_scheduled = false;
++
++	if (!is_scheduled) {
++		// reply immediately
++		serve_request(new_task, sock);
++		free(new_task);
++	}
++}
+ 
+ int main(int argc, char **argv) {
+ 	const int one = 1;
+@@ -376,6 +563,8 @@ int main(int argc, char **argv) {
+ 	struct sockaddr_in6 server_addr = {};
+ 	struct in6_addr mgroup_addr;
+ 
++	srand(time(NULL));
++
+ 	sock = socket(PF_INET6, SOCK_DGRAM, 0);
+ 
+ 	if (sock < 0) {
+@@ -388,15 +577,24 @@ int main(int argc, char **argv) {
+ 		exit(EXIT_FAILURE);
+ 	}
+ 
++	if (setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO, &one, sizeof(one))) {
++		perror("can't set socket to deliver IPV6_PKTINFO control message");
++		exit(EXIT_FAILURE);
++	}
++
+ 	server_addr.sin6_family = AF_INET6;
+ 	server_addr.sin6_addr = in6addr_any;
+ 
++	char *endptr;
+ 	opterr = 0;
+ 
+ 	int group_set = 0;
++	bool iface_set = false;
++	unsigned int last_ifindex = 0;
++	struct interface_delay_info *if_delay_info_list = NULL;
+ 
+ 	int c;
+-	while ((c = getopt(argc, argv, "p:g:i:d:h")) != -1) {
++	while ((c = getopt(argc, argv, "p:g:t:i:d:h")) != -1) {
+ 		switch (c) {
+ 		case 'p':
+ 			server_addr.sin6_port = htons(atoi(optarg));
+@@ -416,7 +614,38 @@ int main(int argc, char **argv) {
+ 				fprintf(stderr, "Multicast group must be given before interface.\n");
+ 				exit(EXIT_FAILURE);
+ 			}
+-			join_mcast(sock, mgroup_addr, optarg);
++			iface_set = true;
++			last_ifindex = if_nametoindex(optarg);
++			if(!join_mcast(sock, mgroup_addr, last_ifindex)) {
++				fprintf(stderr, "Could not join multicast group on %s: ", optarg);
++				last_ifindex = 0;
++			}
++			break;
++
++		case 't':
++			if (!iface_set) {
++				fprintf(stderr, "Interface must be given before max response delay.\n");
++				exit(EXIT_FAILURE);
++			}
++
++			uint64_t max_multicast_delay = UINT64_C(1000) * strtoul(optarg, &endptr, 10);
++			if (!*optarg || *endptr || max_multicast_delay > INT64_MAX) {
++				fprintf(stderr, "Invalid multicast delay\n");
++				exit(EXIT_FAILURE);
++			}
++
++			if (last_ifindex) {
++				// insert the interface delay info at the beginning of the list
++				struct interface_delay_info **head = &if_delay_info_list;
++				struct interface_delay_info *old_head = if_delay_info_list;
++
++				*head = malloc(sizeof(*if_delay_info_list));
++				(*head)->ifindex = last_ifindex;
++				(*head)->max_multicast_delay = max_multicast_delay;
++				(*head)->next = old_head;
++			}
++
++
+ 			break;
+ 
+ 		case 'd':
+@@ -443,8 +672,19 @@ int main(int argc, char **argv) {
+ 
+ 	load_providers();
+ 
+-	while (true)
+-		serve(sock);
++	struct request_schedule schedule = {};
++
++	while (true) {
++		accept_request(&schedule, sock, if_delay_info_list);
++
++		struct request_task *task = schedule_pop_request(&schedule);
++
++		if (!task)
++			continue;
++
++		serve_request(task, sock);
++		free(task);
++	}
+ 
+ 	return EXIT_FAILURE;
+ }
+-- 
+2.11.0
+
-- 
2.13.2

