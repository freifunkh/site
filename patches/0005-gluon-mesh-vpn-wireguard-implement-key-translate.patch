From 503cf494ab388302e716b9fbd75c09833d650de5 Mon Sep 17 00:00:00 2001
From: "aiyion.prime" <git@aiyionpri.me>
Date: Sat, 6 Aug 2022 14:14:03 +0200
Subject: [PATCH 1/2] gluon-mesh-vpn-wireguard: implement key-translate

takes a fastd private key in legacy form
and emits it in base64 encoded (WireGuard) form

Provides basic return codes and error messages.

optional parameters:
  -n    do not output the trailing newline
---
 package/gluon-mesh-vpn-wireguard/Makefile     |  8 +-
 package/gluon-mesh-vpn-wireguard/src/Makefile |  5 +-
 .../src/gluon-mesh-vpn-key-translate.c        | 82 +++++++++++++++++++
 3 files changed, 93 insertions(+), 2 deletions(-)
 create mode 100644 package/gluon-mesh-vpn-wireguard/src/gluon-mesh-vpn-key-translate.c

diff --git a/package/gluon-mesh-vpn-wireguard/Makefile b/package/gluon-mesh-vpn-wireguard/Makefile
index 61c53332..ba69a7d4 100644
--- a/package/gluon-mesh-vpn-wireguard/Makefile
+++ b/package/gluon-mesh-vpn-wireguard/Makefile
@@ -6,7 +6,13 @@ include ../gluon.mk
 
 define Package/gluon-mesh-vpn-wireguard
   TITLE:=Support for connecting meshes via wireguard
-  DEPENDS:=+gluon-core +libgluonutil +gluon-mesh-vpn-core +wireguard-tools +wgpeerselector +libubus
+  DEPENDS:=+gluon-core +libgluonutil +gluon-mesh-vpn-core +wireguard-tools +wgpeerselector +libubox +libubus
+endef
+
+define Package/gluon-mesh-vpn-wireguard/install
+	$(Gluon/Build/Install)
+	$(INSTALL_DIR) $(1)/usr/sbin
+	$(INSTALL_BIN) $(PKG_BUILD_DIR)/gluon-mesh-vpn-key-translate $(1)/usr/sbin/
 endef
 
 $(eval $(call BuildPackageGluon,gluon-mesh-vpn-wireguard))
diff --git a/package/gluon-mesh-vpn-wireguard/src/Makefile b/package/gluon-mesh-vpn-wireguard/src/Makefile
index 0b027848..16f12c61 100644
--- a/package/gluon-mesh-vpn-wireguard/src/Makefile
+++ b/package/gluon-mesh-vpn-wireguard/src/Makefile
@@ -1,6 +1,9 @@
-all: respondd.so
+all: respondd.so gluon-mesh-vpn-key-translate
 
 CFLAGS += -Wall -Werror-implicit-function-declaration
 
+gluon-mesh-vpn-key-translate: gluon-mesh-vpn-key-translate.c
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) -Wall -o $@ $^ $(LDLIBS) -lubox
+
 respondd.so: respondd.c
 	$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) -shared -fPIC -D_GNU_SOURCE -o $@ $^ $(LDLIBS) -lgluonutil -lubus
diff --git a/package/gluon-mesh-vpn-wireguard/src/gluon-mesh-vpn-key-translate.c b/package/gluon-mesh-vpn-wireguard/src/gluon-mesh-vpn-key-translate.c
new file mode 100644
index 00000000..ad3090e1
--- /dev/null
+++ b/package/gluon-mesh-vpn-wireguard/src/gluon-mesh-vpn-key-translate.c
@@ -0,0 +1,82 @@
+// SPDX-FileCopyrightText: 2022 Jan-Niklas Burfeind <gluon@aiyionpri.me>
+// SPDX-License-Identifier: BSD-2-Clause
+// SPDX-FileContributor: read_key() by Matthias Schiffer <mschiffer@universe-factory.net>
+
+#include <libubox/utils.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define FASTD_KEY_LEN_HEX 64
+
+static inline void invalid_key(void) {
+	fprintf(stderr, "Error: Invalid fastd key provided.\n");
+	exit(1);
+}
+
+static inline void no_mem(void) {
+	fprintf(stderr, "Error: Not enough memory for base64 encoding available.\n");
+	exit(1);
+}
+
+static inline void usage(void) {
+	fprintf(stderr, "Usage: gluon-mesh-vpn-key-translate [-n] <fastd secret>\n");
+	fprintf(stderr, "-n     do not output the trailing newline\n");
+	exit(1);
+}
+
+static inline bool read_key(uint8_t key[32], const char *hexkey) {
+	if ((strlen(hexkey) != 64) || (strspn(hexkey, "0123456789abcdefABCDEF") != 64))
+		return false;
+
+	size_t i;
+	for (i = 0; i < 32; i++)
+		sscanf(&hexkey[2 * i], "%02hhx", &key[i]);
+
+	return true;
+}
+
+int main(int argc, char *argv[]) {
+	bool newline = true;
+	if (argc < 2 || argc > 3) {
+		usage();
+	} else if (argc == 3) {
+		if (strcmp(argv[1], "-n")) {
+			usage();
+		} else {
+			newline = false;
+		}
+	}
+	int fastd_pos = argc - 1;
+	int fastd_len = strlen(argv[fastd_pos]);
+
+	if (FASTD_KEY_LEN_HEX != fastd_len)
+		invalid_key();
+
+	uint8_t fastd_keystore[32];
+	read_key(fastd_keystore, argv[fastd_pos]);
+
+	// l is always 45 ((((32) + 2) / 3) * 4 + 1)
+	int l = B64_ENCODE_LEN(32);
+	char *str = malloc(l);
+	if (str == NULL) {
+		no_mem();
+	}
+
+	int ret = b64_encode(fastd_keystore, 32, str, l);
+
+	if (l - 1 != ret) {
+		free(str);
+		invalid_key();
+	}
+
+	if (newline) {
+		printf("%s\n", str);
+	} else {
+		printf("%s", str);
+	}
+
+	free(str);
+	return 0;
+}
-- 
2.37.3

